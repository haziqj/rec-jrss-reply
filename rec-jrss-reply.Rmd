---
title: "Random Ensemble Classification using Gaussian Process Regression"
author: "Haziq Jamil"
date: "19/03/2017"
output: html_document
---

```{r setup, include = FALSE}
library(iprior)
library(RPEnsemble)
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Function to create test and train set
testTrain <- function(n = 50, seed = NULL) {
  if (!is.null(seed)) set.seed(seed)
  train.index <- sample(1:length(y), size = n, replace = FALSE)
  test.index <- (1:length(y))[-train.index]
  
  X.train <- X[train.index, ]
  y.train <- y[train.index]
  X.test <- X[test.index, ]
  y.test <- y[test.index]
  
  list(X.train = X.train, y.train = y.train, X.test = X.test, y.test = y.test)
}

# Function to tabulate mean and se
tabRes <- function(...) {
  this <- list(...)
  K <- length(this)
  tab <- NULL
  
  for (k in 1:K) {
    tab.mean <- apply(this[[k]], 2, mean)
    tab.se <- apply(this[[k]], 2, sd) / 10
    tab.mean.and.se <- paste0(round(tab.mean, 2), " (", 
                              round(tab.se, 2), ")")
    tab <- rbind(tab, tab.mean.and.se)
  }
  
  rownames(tab) <- names(this)
  colnames(tab) <- colnames(this[[1]])
  as.data.frame(tab)
}

# Function for inner simulations
innerSim <- function(n, kernel, ipriorfunction, gpr, fbmoptim = FALSE) {
  dat <- testTrain(n = n)
  mod <- kernL(dat$y.train, dat$X.train, 
               model = list(kernel = kernel, rootkern = gpr))
  if (fbmoptim) {
    mod <- ipriorfunction(mod, silent = TRUE)
  } else {
    mod <- ipriorfunction(mod, control = list(silent = TRUE))
  }
  y.test <- round(predict(mod, newdata = list(dat$X.test)))
  sum(y.test != dat$y.test) / (N - n) * 100
}
# innerSim(50, "FBM", fbmOptim, gpr = FALSE, fbmoptim = TRUE)

# Function for GPR/I-prior simulations
mySim <- function(y = y, X = X.orig, nsim = 100, n = c(50, 100, 200), 
                  type = c("linear", "fbm", "fbmoptim"), gpr = FALSE,
                  starting = 1) {
  type <- match.arg(type, c("linear", "fbm", "fbmoptim"))
  res.tmp <- matrix(NA, ncol = length(n), nrow = nsim)
  colnames(res.tmp) <- paste0(c("n = "), n)
  pb <- txtProgressBar(min = 0, max = nsim * length(n), style = 3)
  
  ipriorfn <- ipriorOptim
  fbmoptim <- FALSE
  if (type == "linear") {
    kernel <- "Canonical"
  }
  if (type == "fbm") {
    kernel <- "FBM"
  }
  if (type == "fbmoptim") {
    kernel <- "FBM"
    ipriorfn <- fbmOptim
    fbmoptim <- TRUE
  }
  
  count <- 0
  for (i in staring:nsim) {
    for (j in 1:length(n)) {
      res.tmp[i, j] <- innerSim(n[j], kernel = kernel, ipriorfunction = ipriorfn,
                                gpr = gpr, fbmoptim = fbmoptim)
      count <- count + 1
      setTxtProgressBar(pb, count)
    }
  }
  close(pb)

  res.tmp
}
# mySim(nsim = 1)
```

## Ionosphere data set

```{r}
# https://archive.ics.uci.edu/ml/datasets/Ionosphere
# p = 34 (radar data), N = 350
ion <- read.table("ionosphere.data.txt", sep = ",", header = TRUE)
summary(ion$g)
X.orig <- as.matrix(ion[, -35])
y <- as.numeric(ion$g)
y[y == 2] <- 0  # convert good = 0
N <- length(y)
```

```{r sims, cache = TRUE, include = FALSE}
res.gprlin <- mySim(type = "linear", gpr = TRUE)  # linear GPR
res.gprfbm <- mySim(type = "fbm", gpr = TRUE)  # FBM GPR
res.gprfbmoptim <- mySim(type = "fbmoptim", gpr = TRUE)  # FBM optim GPR

res.iplin <- mySim(type = "linear")  # Canonical I-prior
res.ipfbm <- mySim(type = "fbm")  # FBM I-prior
res.ipfbmoptim <- mySim(type = "fbmoptim")  # FBM optim I-prior
```

```{r, echo = FALSE}
tab <- tabRes("GPR (linear)"      = res.gprlin, 
              "GPR (FBM)"         = res.gprfbm, 
              "GPR (FBM MLE)"     = res.gprfbmoptim,
              "I-prior (linear)"  = res.iplin, 
              "I-prior (FBM)"     = res.ipfbm, 
              "I-prior (FBM MLE)" = res.ipfbmoptim)
rp.lda5 <- c("13.05 (0.38)", "10.75 (0.25)", "9.78 (0.26)")
rp.qda5 <- c("8.14 (0.37)", "6.15 (0.37)", "5.21 (0.20)")
rp.knn5 <- c("13.05 (0.46)", "7.43 (0.25)", "5.43 (0.19)")
rp.tab <- rbind("RP-LDA5" = rp.lda5, "RP-QDA5" = rp.qda5, "RP-knn5" = rp.knn5)
colnames(rp.tab) <- colnames(tab)
tab <- rbind(tab, rp.tab)
tab
```








```{r}
# Random projection matrix. set d = 10
A <- RPGenerate(p = ncol(X.orig), d = 10)

# Project to B2 = 10 non-overlapping blocks
X <- X.orig %*% A
tmp <- NULL
for (i in 0:9) tmp[[i + 1]] <- X[, (10 * i + 1):(10 * i + 10)]

# Data
X <- tmp[[1]]
dat <- testTrain()
```





